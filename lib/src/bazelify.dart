import 'dart:async';
import 'dart:io';

import 'package:meta/meta.dart';
import 'package:path/path.dart' as path;

import 'build_file.dart';
import 'pubspec.dart';

/// Turns a local directory into a Bazel repository.
///
/// See: https://www.bazel.io/versions/master/docs/be/workspace.html#new_local_repository
class LocalRepository {
  /// A parsed pubspec.yaml for the package.
  final Pubspec pubspec;

  /// Local file path.
  final String path;

  /// Create a `new_local_repository` macro.
  LocalRepository(this.pubspec, {@required this.path});

  /// Returns the contents of a suitable section of a .bzl file.
  String getRepository() {
    var buffer = new StringBuffer()
      ..writeln('native.new_local_repository(')
      ..writeln('    name = "${pubspec.packageName}",')
      ..writeln('    path = "$path",')
      ..writeln('    build_file = ".bazelify/${pubspec.packageName}.BUILD",')
      ..writeln(')');
    return buffer.toString();
  }

  /// Returns the contents of a suitable BUILD file for the repository.
  String getBuild() => new BuildFile(pubspec).forRepository();

  @override
  String toString() =>
      'LocalRepository {' +
      {
        'name': pubspec.packageName,
        'path': pubspec.packageName,
        'deps': pubspec.deps,
      }.toString() +
      '}';
}

/// Generates a stream of repositories from [packages].
///
/// For the following:
///     ```
///     args:file:///.../.pub-cache/hosted/pub.dartlang.org/args-0.13.6/lib/
///     path:file:///.../.pub-cache/hosted/pub.dartlang.org/path-1.4.0/lib/
///     ```
///
/// Returns (as a stream) a LocalRepository from the pubspec.yaml for each
/// package.
Stream<LocalRepository> pubBazelRepos(Map<String, Uri> packages) async* {
  for (var name in packages.keys) {
    var files = packages[name].toString();
    if (files == 'lib/') continue;
    files = files.substring(0, files.length - '/lib/'.length);
    var pubspecUri = Uri.parse(path.join(files, 'pubspec.yaml'));
    var pubspec =
        new Pubspec(await new File.fromUri(pubspecUri).readAsString());
    yield new LocalRepository(
      pubspec,
      path: new File.fromUri(Uri.parse(files)).absolute.path,
    );
  }
}

/// Writes a new 'packages.bzl' file in [workspaceDir].
///
/// Returns a [Future] that completes with the file contents when done.
Future<String> generateBzl(
  String workspaceDir,
  Stream<LocalRepository> repositories,
) async {
  var pubspecPath = path.join(workspaceDir, 'pubspec.yaml');
  var pubspec = new Pubspec(await new File(pubspecPath).readAsString());
  var bazelifyDir = new Directory(path.join(workspaceDir, '.bazelify'));
  if (await bazelifyDir.exists()) {
    await bazelifyDir.delete(recursive: true);
  }
  await bazelifyDir.create(recursive: true);
  var buffer = new StringBuffer();
  buffer.writeln('''PUB_PACKAGE_NAME = "${pubspec.packageName}"

def bazelify():''');
  await for (var repo in repositories) {
    var repoRule = repo
        .getRepository()
        .split('\n')
        .map((line) => ' ' * 4 + line)
        .join('\n');
    buffer.writeln(repoRule);
    var buildFile = path.join(
        workspaceDir, '.bazelify', '${repo.pubspec.packageName}.BUILD');
    await new File(buildFile).writeAsString(repo.getBuild());
  }
  await new File(path.join(workspaceDir, 'BUILD'))
      .writeAsString('# Automatically generated and left blank by Bazelify\n');
  await new File(path.join(workspaceDir, 'WORKSPACE'))
      .writeAsString(_workspace);
  await new File(path.join(workspaceDir, 'packages.bzl'))
      .writeAsString(buffer.toString());
  return buffer.toString();
}

const _workspace = r'''
# Auto-generated by Bazelify. Do not modify by hand.

# Include the Dart language extensions to Bazel.
git_repository(
    name = "io_bazel_rules_dart",
    remote = "https://github.com/dart-lang/rules_dart",
    tag = "0.0.0-alpha",
)
load(
    "@io_bazel_rules_dart//dart/build_rules:repositories.bzl",
    "dart_repositories",
)
dart_repositories()

# Include packages defined in pubspec.yaml.
load("//:packages.bzl", "bazelify")
bazelify()
''';
